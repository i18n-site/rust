# xrpc: A Transport-Agnostic RPC Framework

A framework for building transport-agnostic RPC services. It provides a set of traits and structures to abstract the underlying communication protocol, allowing developers to focus on business logic.

## Table of Contents

- [Design Philosophy](#design-philosophy)
- [Core Concepts](#core-concepts)
- [Usage Example](#usage-example)
- [Directory Structure](#directory-structure)
- [A Brief History of RPC](#a-brief-history-of-rpc)

## Design Philosophy

The core idea behind `xrpc` is the separation of concerns. An RPC call is broken down into distinct stages:

1.  **Request Reception & Parsing**: The transport layer (e.g., gRPC, HTTP) receives a request and parses it into arguments.
2.  **Business Logic Execution**: The core logic of the RPC method is executed.
3.  **Response Generation**: The result of the business logic is converted back into a transport-specific response.

`xrpc` provides traits to standardize the second stage, while offering hooks and adapters for the first and third. This makes the core application logic independent of the transport layer. The `call!` macro automates logging, timing, and error handling, further simplifying the developer's task.

## Core Concepts

The primary components of `xrpc` are exposed in `src/lib.rs`.

-   **`trait Func`**: Defines the basic signature of an RPC function, associating `Args` and a `Result` type.
-   **`trait Call` / `trait AsyncCall`**: Implement these traits for your synchronous or asynchronous RPC functions. You define the `inner` method, and the `call` method (provided by the `call!` macro) wraps it with logging, error handling, and metrics.
-   **`struct ReqArgs`**: A wrapper that provides the `inner` method with the request context (including headers) and the parsed arguments.
-   **`trait Req`**: Represents an incoming request, providing a method `ext` to access request-scoped extension data.
-   **`trait Ext`**: A trait for extracting and initializing request-scoped data, such as user sessions or database connections, in a lazy-loaded fashion.
-   **`enum Result<T>`**: A specialized result type for `inner` methods. It can be:
    -   `Ok(T)`: The operation was successful.
    -   `Err(anyhow::Error)`: A generic error occurred. The framework will automatically convert this to a standard 500-level error response.
    -   `Response(Response)`: The method needs to return a specific error response (e.g., a 404 Not Found).
-   **`struct Response`**: Represents a direct error response with a status code and body.

## Usage Example

Since the project does not contain a `tests/` directory, here is a conceptual example of how to define and use an RPC service with `xrpc` and `volo-grpc`.

First, define your service and its methods in a `.proto` file:

```proto
syntax = "proto3";

message HelloRequest {
    string name = 1;
}

message HelloResponse {
    string message = 1;
}

service Greeter {
    rpc SayHello(HelloRequest) returns (HelloResponse);
}
```

Next, implement the `AsyncCall` trait for your `SayHello` RPC:

```rust
use xrpc::{AsyncCall, Func, ReqArgs, Result};
use your_generated_types::{HelloRequest, HelloResponse}; // Assuming types generated by prost/pilota

pub struct SayHello;

impl Func for SayHello {
    type Args = HelloRequest;
    type Result = HelloResponse;

    fn name() -> &'static str {
        "SayHello"
    }
}

impl AsyncCall for SayHello {
    async fn inner<H: Map, E: Ext>(req_args: ReqArgs<H, E, Self::Args>) -> Result<Self::Result> {
        let message = format!("Hello, {}!", req_args.args.name);
        Result::Ok(HelloResponse { message })
    }
}
```

Finally, integrate it into your `volo-grpc` service implementation:

```rust
use volo_grpc::Request;
use xrpc::volo::grpc::{split, IntoResponse};
use xrpc::Call; // Use Call or AsyncCall

// Assuming a volo service struct
pub struct MyService;

#[volo::async_trait]
impl Greeter for MyService {
    async fn say_hello(&self, req: Request<HelloRequest>) -> Result<Response<HelloResponse>, Status> {
        // 1. Split the volo request into xrpc parts
        let (req, args) = split(req);
        
        // 2. Execute the xrpc call
        let result = SayHello::call::<MyLogger, _, _>((&req, args)).await;

        // 3. Convert the xrpc result back into a volo response
        result.into_response()
    }
}
```

## Directory Structure

```
/
├── Cargo.toml       # Package manifest
├── AGENTS.md        # Agent instructions
├── src/             # Source code
│   ├── lib.rs       # Main library file, exports public APIs
│   ├── call.rs      # Defines the core `Call` and `AsyncCall` traits
│   ├── response.rs  # Defines the `Response` struct for direct error returns
│   ├── result.rs    # Defines the `Result` enum for RPC outcomes
│   └── volo/        # Adapters for the Volo framework
│       ├── mod.rs
│       ├── grpc.rs  # gRPC-specific helpers
│       └── http.rs  # HTTP-specific helpers
└── readme/          # README files
    ├── en.md        # English README
    └── zh.md        # Chinese README
```

## A Brief History of RPC

Remote Procedure Calls (RPC) are a cornerstone of distributed systems. The concept originated in the 1970s, with one of the first major implementations being at Xerox PARC. The idea was simple yet powerful: make a function call on a remote machine look and feel like a local one.

The 1980s popularized the term, largely thanks to Sun Microsystems and their implementation used in the Network File System (NFS). This era was dominated by technologies like SunRPC (later ONC RPC) and DCE/RPC.

The rise of the web in the 2000s brought RPC to HTTP, with protocols like XML-RPC and SOAP (Simple Object Access Protocol). These used text-based formats (XML) for communication, which offered interoperability at the cost of performance.

Modern RPC, driven by the microservices boom, has shifted back towards high-performance binary protocols. Frameworks like Google's gRPC (which uses Protocol Buffers) and Apache Thrift dominate the landscape. They offer features essential for modern distributed applications, such as efficient serialization, streaming, and language independence, continuing the evolution of that initial idea from the 1970s.
